<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FingerGolf Level Editor</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    display: flex;
    height: 100vh;
    overflow: hidden;
    user-select: none;
  }

  /* Sidebar */
  #sidebar {
    width: 280px;
    background: #16213e;
    border-right: 1px solid #0f3460;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
  }
  #sidebar h2 {
    padding: 16px;
    font-size: 18px;
    border-bottom: 1px solid #0f3460;
    color: #4ecca3;
  }

  .section { padding: 12px 16px; border-bottom: 1px solid #0f3460; }
  .section h3 { font-size: 13px; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }

  label { display: block; font-size: 13px; margin-bottom: 4px; color: #aaa; }
  input[type="text"], input[type="number"] {
    width: 100%;
    padding: 6px 10px;
    background: #1a1a2e;
    border: 1px solid #0f3460;
    border-radius: 6px;
    color: #e0e0e0;
    font-size: 14px;
    margin-bottom: 8px;
  }
  input:focus { outline: none; border-color: #4ecca3; }

  .inline-inputs { display: flex; gap: 8px; }
  .inline-inputs > div { flex: 1; }

  /* Piece palette */
  #palette {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
  }
  .piece-category { margin-bottom: 12px; }
  .piece-category h4 {
    font-size: 11px;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 4px;
    padding: 0 4px;
  }
  .piece-btn {
    display: inline-block;
    padding: 4px 8px;
    margin: 2px;
    background: #1a1a2e;
    border: 1px solid #0f3460;
    border-radius: 4px;
    color: #ccc;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.15s;
  }
  .piece-btn:hover { background: #0f3460; color: #fff; }
  .piece-btn.selected { background: #4ecca3; color: #1a1a2e; border-color: #4ecca3; font-weight: 600; }

  .special-btn {
    display: inline-block;
    padding: 5px 10px;
    margin: 2px;
    border: 1px solid;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    font-weight: 600;
  }
  .ball-btn { background: #2d5016; border-color: #4ecca3; color: #4ecca3; }
  .ball-btn.selected { background: #4ecca3; color: #1a1a2e; }
  .hole-btn { background: #501616; border-color: #e74c3c; color: #e74c3c; }
  .hole-btn.selected { background: #e74c3c; color: #fff; }
  .eraser-btn { background: #3d2c08; border-color: #f39c12; color: #f39c12; }
  .eraser-btn.selected { background: #f39c12; color: #1a1a2e; }

  /* Main area */
  #main {
    flex: 1;
    display: flex;
    flex-direction: column;
  }

  /* Toolbar */
  #toolbar {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    background: #16213e;
    border-bottom: 1px solid #0f3460;
    gap: 12px;
  }
  .toolbar-group {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .toolbar-group span { font-size: 12px; color: #888; margin-right: 4px; }
  .tb-btn {
    padding: 6px 12px;
    background: #1a1a2e;
    border: 1px solid #0f3460;
    border-radius: 4px;
    color: #ccc;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s;
  }
  .tb-btn:hover { background: #0f3460; color: #fff; }
  .tb-btn.active { background: #4ecca3; color: #1a1a2e; border-color: #4ecca3; }
  .tb-btn.accent { background: #0f3460; border-color: #4ecca3; color: #4ecca3; }
  .tb-btn.accent:hover { background: #4ecca3; color: #1a1a2e; }
  .tb-btn.danger { border-color: #e74c3c; color: #e74c3c; }
  .tb-btn.danger:hover { background: #e74c3c; color: #fff; }

  .toolbar-sep { width: 1px; height: 24px; background: #0f3460; }

  #rotation-label {
    font-size: 12px;
    color: #4ecca3;
    font-weight: 600;
    min-width: 30px;
    text-align: center;
  }

  /* Canvas */
  #canvas-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    cursor: crosshair;
  }
  canvas {
    position: absolute;
    top: 0;
    left: 0;
  }

  /* Coords display */
  #coords {
    position: absolute;
    bottom: 12px;
    left: 12px;
    font-size: 12px;
    color: #666;
    pointer-events: none;
  }

  /* Export modal */
  #export-modal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }
  #export-modal.visible { display: flex; }
  #export-content {
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 12px;
    padding: 24px;
    width: 90%;
    max-width: 700px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
  }
  #export-content h2 { margin-bottom: 12px; color: #4ecca3; }
  #export-content textarea {
    flex: 1;
    min-height: 300px;
    background: #1a1a2e;
    color: #4ecca3;
    border: 1px solid #0f3460;
    border-radius: 8px;
    padding: 12px;
    font-family: 'SF Mono', 'Menlo', monospace;
    font-size: 12px;
    resize: none;
  }
  #export-content .modal-btns {
    display: flex;
    gap: 8px;
    margin-top: 12px;
    justify-content: flex-end;
  }
</style>
</head>
<body>

<div id="sidebar">
  <h2>FingerGolf Level Editor</h2>

  <div class="section">
    <h3>Course Info</h3>
    <label>Name</label>
    <input type="text" id="course-name" value="My Course" />
    <label>Par</label>
    <input type="number" id="course-par" value="3" min="1" max="12" />
  </div>

  <div class="section">
    <h3>Tools</h3>
    <div style="margin-bottom: 8px;">
      <span class="special-btn ball-btn" id="ball-tool" onclick="selectTool('ball')">Ball Start</span>
      <span class="special-btn hole-btn" id="hole-tool" onclick="selectTool('hole')">Hole</span>
      <span class="special-btn eraser-btn" id="eraser-tool" onclick="selectTool('eraser')">Eraser</span>
    </div>
  </div>

  <div class="section" style="flex:1; display:flex; flex-direction:column; min-height:0;">
    <h3>Pieces</h3>
    <div id="palette"></div>
  </div>
</div>

<div id="main">
  <div id="toolbar">
    <div class="toolbar-group">
      <span>View:</span>
      <button class="tb-btn active" onclick="setViewAngle(0)" id="view-0">NE</button>
      <button class="tb-btn" onclick="setViewAngle(1)" id="view-1">SE</button>
      <button class="tb-btn" onclick="setViewAngle(2)" id="view-2">SW</button>
      <button class="tb-btn" onclick="setViewAngle(3)" id="view-3">NW</button>
    </div>

    <div class="toolbar-sep"></div>

    <div class="toolbar-group">
      <span>Piece Rot:</span>
      <button class="tb-btn" onclick="cyclePieceRotation(-1)">&larr;</button>
      <span id="rotation-label">0&deg;</span>
      <button class="tb-btn" onclick="cyclePieceRotation(1)">&rarr;</button>
    </div>

    <div class="toolbar-sep"></div>

    <div class="toolbar-group">
      <button class="tb-btn accent" onclick="exportCourse()">Export Swift</button>
      <button class="tb-btn accent" onclick="exportJSON()">Export JSON</button>
      <button class="tb-btn" onclick="importJSON()">Import JSON</button>
    </div>

    <div style="flex:1"></div>

    <div class="toolbar-group">
      <button class="tb-btn danger" onclick="clearAll()">Clear All</button>
    </div>
  </div>

  <div id="canvas-container">
    <canvas id="canvas"></canvas>
    <div id="coords"></div>
  </div>
</div>

<div id="export-modal">
  <div id="export-content">
    <h2 id="export-title">Export</h2>
    <textarea id="export-text" readonly></textarea>
    <div class="modal-btns">
      <button class="tb-btn" onclick="copyExport()">Copy to Clipboard</button>
      <button class="tb-btn" onclick="closeExport()">Close</button>
    </div>
  </div>
</div>

<script>
// ============================================================
// STATE
// ============================================================
const GRID_SIZE = 20; // max grid
let pieces = {}; // key: "x,z" -> { model, rotation }
let ballStart = { x: 0, z: 0 };
let holePos = { x: 2, z: 2 };
let viewAngle = 0; // 0=NE, 1=SE, 2=SW, 3=NW
let selectedPiece = 'end';
let currentTool = 'piece'; // 'piece', 'ball', 'hole', 'eraser'
let pieceRotation = 0;
let hoverCell = null;

// Camera pan/zoom
let camX = 0, camY = 0, zoom = 1;
let isPanning = false, panStartX = 0, panStartY = 0, panStartCamX = 0, panStartCamY = 0;

// Tile dimensions (isometric)
const TILE_W = 64;
const TILE_H = 32;

// ============================================================
// PIECE CATALOG
// ============================================================
const PIECE_CATEGORIES = {
  'Basic': ['end', 'straight', 'corner', 'inner-corner', 'open', 'side', 'gap', 'crest'],
  'Turns': ['round-corner-a', 'round-corner-b', 'round-corner-c', 'round-large-corner', 'round-large-corner-open', 'skew-corner', 'skew-large-corner', 'skew-large-corner-open', 'square-corner-a'],
  'Ramps': ['ramp', 'ramp-low', 'ramp-medium', 'ramp-high', 'ramp-large', 'ramp-large-side', 'ramp-sharp', 'ramp-side', 'ramp-square'],
  'Hills': ['hill-corner', 'hill-round', 'hill-square', 'bump', 'bump-down', 'bump-walls', 'bump-down-walls'],
  'Obstacles': ['obstacle-block', 'obstacle-diamond', 'obstacle-triangle', 'narrow-block', 'narrow-round', 'narrow-square', 'block', 'block-borders'],
  'Tunnels': ['tunnel-narrow', 'tunnel-wide', 'tunnel-double'],
  'Splits': ['split', 'split-t', 'split-start', 'split-walls-to-open', 'walls-to-open'],
  'Walls': ['wall-left', 'wall-right'],
  'Structures': ['structure-windmill', 'windmill', 'structure-gate', 'structure-gate-building', 'structure-gate-wide', 'structure-gates', 'castle'],
  'Spline Concave': ['spline-concave', 'spline-concave-cap-back', 'spline-concave-cap-front', 'spline-concave-corner-large', 'spline-concave-corner-small', 'spline-concave-curve', 'spline-concave-looping', 'spline-concave-straight', 'spline-concave-straight-bend', 'spline-concave-straight-bend-large', 'spline-concave-straight-bump-down', 'spline-concave-straight-bump-up', 'spline-concave-straight-hill-beginning', 'spline-concave-straight-hill-complete', 'spline-concave-straight-hill-complete-half', 'spline-concave-straight-hill-end', 'spline-concave-straight-skew-left', 'spline-concave-straight-skew-left-side', 'spline-concave-straight-skew-right', 'spline-concave-straight-skew-right-side', 'spline-concave-corner-large-ramp', 'spline-concave-corner-small-ramp'],
  'Spline Default': ['spline-default', 'spline-default-cap-back', 'spline-default-cap-front', 'spline-default-corner-large', 'spline-default-corner-small', 'spline-default-curve', 'spline-default-looping', 'spline-default-straight', 'spline-default-straight-bend', 'spline-default-straight-bend-large', 'spline-default-straight-bump-down', 'spline-default-straight-bump-up', 'spline-default-straight-hill-beginning', 'spline-default-straight-hill-complete', 'spline-default-straight-hill-complete-half', 'spline-default-straight-hill-end', 'spline-default-straight-skew-left', 'spline-default-straight-skew-left-side', 'spline-default-straight-skew-right', 'spline-default-straight-skew-right-side', 'spline-default-corner-large-ramp', 'spline-default-corner-small-ramp'],
  'Support': ['support', 'support-bottom', 'support-low', 'support-low-bottom', 'supports', 'supports-bottom', 'supports-low', 'supports-low-bottom'],
};

// Color map for piece categories
const CATEGORY_COLORS = {
  'Basic':          { fill: '#4ecca3', stroke: '#2d8a6e' },
  'Turns':          { fill: '#6c9bdb', stroke: '#4a7ab8' },
  'Ramps':          { fill: '#e8a838', stroke: '#c08020' },
  'Hills':          { fill: '#c8a050', stroke: '#a08040' },
  'Obstacles':      { fill: '#e06060', stroke: '#b84040' },
  'Tunnels':        { fill: '#9b6ed0', stroke: '#7a50b0' },
  'Splits':         { fill: '#5cb8b2', stroke: '#3a9090' },
  'Walls':          { fill: '#a0a0a0', stroke: '#808080' },
  'Structures':     { fill: '#d0a0d0', stroke: '#b080b0' },
  'Spline Concave': { fill: '#70b870', stroke: '#509850' },
  'Spline Default': { fill: '#80c880', stroke: '#60a860' },
  'Support':        { fill: '#808888', stroke: '#606868' },
};

function getCategoryForPiece(model) {
  for (const [cat, pieces] of Object.entries(PIECE_CATEGORIES)) {
    if (pieces.includes(model)) return cat;
  }
  return 'Basic';
}

// ============================================================
// PALETTE SETUP
// ============================================================
function buildPalette() {
  const pal = document.getElementById('palette');
  pal.innerHTML = '';
  for (const [cat, models] of Object.entries(PIECE_CATEGORIES)) {
    const div = document.createElement('div');
    div.className = 'piece-category';
    const h4 = document.createElement('h4');
    h4.textContent = cat;
    div.appendChild(h4);
    for (const m of models) {
      const btn = document.createElement('span');
      btn.className = 'piece-btn';
      btn.textContent = m;
      btn.dataset.model = m;
      if (m === selectedPiece && currentTool === 'piece') btn.classList.add('selected');
      btn.onclick = () => selectPiece(m);
      div.appendChild(btn);
    }
    pal.appendChild(div);
  }
}

function selectPiece(model) {
  selectedPiece = model;
  currentTool = 'piece';
  updateToolHighlights();
  render();
}

function selectTool(tool) {
  currentTool = tool;
  updateToolHighlights();
  render();
}

function updateToolHighlights() {
  document.querySelectorAll('.piece-btn').forEach(b => {
    b.classList.toggle('selected', b.dataset.model === selectedPiece && currentTool === 'piece');
  });
  document.getElementById('ball-tool').classList.toggle('selected', currentTool === 'ball');
  document.getElementById('hole-tool').classList.toggle('selected', currentTool === 'hole');
  document.getElementById('eraser-tool').classList.toggle('selected', currentTool === 'eraser');
}

// ============================================================
// VIEW ROTATION
// ============================================================
function setViewAngle(angle) {
  viewAngle = angle;
  document.querySelectorAll('#toolbar .toolbar-group:first-child .tb-btn').forEach((b, i) => {
    b.classList.toggle('active', i === angle);
  });
  render();
}

function cyclePieceRotation(dir) {
  pieceRotation = ((pieceRotation / 90 + dir + 4) % 4) * 90;
  document.getElementById('rotation-label').textContent = pieceRotation + '\u00B0';
  render();
}

// ============================================================
// ISOMETRIC PROJECTION
// ============================================================
function worldToScreen(wx, wz) {
  // Rotate world coords based on view angle
  let rx, rz;
  switch (viewAngle) {
    case 0: rx = wx; rz = wz; break;           // NE
    case 1: rx = wz; rz = -wx; break;          // SE (90 CW)
    case 2: rx = -wx; rz = -wz; break;         // SW (180)
    case 3: rx = -wz; rz = wx; break;           // NW (270)
  }
  const sx = (rx - rz) * (TILE_W / 2) * zoom;
  const sy = (rx + rz) * (TILE_H / 2) * zoom;
  return { x: sx + camX, y: sy + camY };
}

function screenToWorld(sx, sy) {
  const lx = (sx - camX) / zoom;
  const ly = (sy - camY) / zoom;

  const rx = (lx / (TILE_W / 2) + ly / (TILE_H / 2)) / 2;
  const rz = (ly / (TILE_H / 2) - lx / (TILE_W / 2)) / 2;

  // Reverse rotation
  let wx, wz;
  switch (viewAngle) {
    case 0: wx = rx; wz = rz; break;
    case 1: wx = -rz; wz = rx; break;
    case 2: wx = -rx; wz = -rz; break;
    case 3: wx = rz; wz = -rx; break;
  }
  return { x: Math.round(wx), z: Math.round(wz) };
}

// ============================================================
// RENDERING
// ============================================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  const container = document.getElementById('canvas-container');
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  // Center camera
  camX = canvas.width / 2;
  camY = canvas.height / 3;
  render();
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw grid
  drawGrid();

  // Collect all cells to draw, sorted by depth
  const cells = [];

  // Grid cells with pieces
  for (const [key, piece] of Object.entries(pieces)) {
    const [x, z] = key.split(',').map(Number);
    cells.push({ x, z, type: 'piece', piece });
  }

  // Ball start
  cells.push({ x: ballStart.x, z: ballStart.z, type: 'ball' });

  // Hole
  cells.push({ x: holePos.x, z: holePos.z, type: 'hole' });

  // Hover preview
  if (hoverCell && currentTool !== 'eraser') {
    cells.push({ x: hoverCell.x, z: hoverCell.z, type: 'hover' });
  }

  // Sort by depth (back to front based on view angle)
  cells.sort((a, b) => {
    const da = getDepth(a.x, a.z);
    const db = getDepth(b.x, b.z);
    return da - db;
  });

  for (const cell of cells) {
    switch (cell.type) {
      case 'piece': drawPiece(cell.x, cell.z, cell.piece); break;
      case 'ball': drawBallMarker(cell.x, cell.z); break;
      case 'hole': drawHoleMarker(cell.x, cell.z); break;
      case 'hover': drawHoverPreview(cell.x, cell.z); break;
    }
  }
}

function getDepth(wx, wz) {
  switch (viewAngle) {
    case 0: return wx + wz;
    case 1: return wz - wx;
    case 2: return -wx - wz;
    case 3: return wx - wz;
  }
}

function drawGrid() {
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1;

  for (let x = -2; x <= GRID_SIZE; x++) {
    for (let z = -2; z <= GRID_SIZE; z++) {
      drawTileOutline(x, z);
    }
  }
}

function getTileCorners(x, z) {
  const top = worldToScreen(x, z);
  const right = worldToScreen(x + 1, z);
  const bottom = worldToScreen(x + 1, z + 1);
  const left = worldToScreen(x, z + 1);
  return { top, right, bottom, left };
}

function drawTileOutline(x, z) {
  const { top, right, bottom, left } = getTileCorners(x, z);
  ctx.beginPath();
  ctx.moveTo(top.x, top.y);
  ctx.lineTo(right.x, right.y);
  ctx.lineTo(bottom.x, bottom.y);
  ctx.lineTo(left.x, left.y);
  ctx.closePath();
  ctx.stroke();
}

function drawFilledTile(x, z, fillColor, strokeColor, height = 0) {
  const { top, right, bottom, left } = getTileCorners(x, z);
  const h = height * TILE_H * zoom;

  // Top face
  ctx.fillStyle = fillColor;
  ctx.strokeStyle = strokeColor;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(top.x, top.y - h);
  ctx.lineTo(right.x, right.y - h);
  ctx.lineTo(bottom.x, bottom.y - h);
  ctx.lineTo(left.x, left.y - h);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  if (height > 0) {
    // Left side face
    ctx.fillStyle = adjustBrightness(fillColor, -30);
    ctx.beginPath();
    ctx.moveTo(left.x, left.y - h);
    ctx.lineTo(bottom.x, bottom.y - h);
    ctx.lineTo(bottom.x, bottom.y);
    ctx.lineTo(left.x, left.y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Right side face
    ctx.fillStyle = adjustBrightness(fillColor, -50);
    ctx.beginPath();
    ctx.moveTo(right.x, right.y - h);
    ctx.lineTo(bottom.x, bottom.y - h);
    ctx.lineTo(bottom.x, bottom.y);
    ctx.lineTo(right.x, right.y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
}

function drawPiece(x, z, piece) {
  const cat = getCategoryForPiece(piece.model);
  const colors = CATEGORY_COLORS[cat] || CATEGORY_COLORS['Basic'];

  // Ramps get slight height
  const isRamp = piece.model.includes('ramp') || piece.model.includes('hill');
  const isStructure = piece.model.includes('structure') || piece.model === 'castle' || piece.model === 'windmill';
  const height = isStructure ? 0.6 : (isRamp ? 0.3 : 0.15);

  drawFilledTile(x, z, colors.fill, colors.stroke, height);

  // Label
  const center = worldToScreen(x + 0.5, z + 0.5);
  const h = height * TILE_H * zoom;
  ctx.fillStyle = '#fff';
  ctx.font = `${Math.max(8, 10 * zoom)}px -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Truncate long names
  let label = piece.model;
  if (label.length > 12) label = label.slice(0, 11) + '..';
  ctx.fillText(label, center.x, center.y - h);

  // Show rotation indicator if non-zero
  if (piece.rotation !== 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = `${Math.max(7, 8 * zoom)}px -apple-system, sans-serif`;
    ctx.fillText(piece.rotation + '\u00B0', center.x, center.y - h + 12 * zoom);
  }
}

function drawBallMarker(x, z) {
  const center = worldToScreen(x + 0.5, z + 0.5);
  const r = 8 * zoom;
  ctx.fillStyle = '#4ecca3';
  ctx.strokeStyle = '#2d8a6e';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(center.x, center.y - 4 * zoom, r, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.max(8, 9 * zoom)}px -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('B', center.x, center.y - 4 * zoom);
}

function drawHoleMarker(x, z) {
  const center = worldToScreen(x + 0.5, z + 0.5);
  const r = 8 * zoom;
  ctx.fillStyle = '#e74c3c';
  ctx.strokeStyle = '#a03020';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(center.x, center.y - 4 * zoom, r, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.max(8, 9 * zoom)}px -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('H', center.x, center.y - 4 * zoom);
}

function drawHoverPreview(x, z) {
  if (currentTool === 'piece') {
    const cat = getCategoryForPiece(selectedPiece);
    const colors = CATEGORY_COLORS[cat] || CATEGORY_COLORS['Basic'];
    ctx.globalAlpha = 0.4;
    drawFilledTile(x, z, colors.fill, colors.stroke, 0.15);
    ctx.globalAlpha = 1;
  } else if (currentTool === 'ball') {
    ctx.globalAlpha = 0.5;
    drawBallMarker(x, z);
    ctx.globalAlpha = 1;
  } else if (currentTool === 'hole') {
    ctx.globalAlpha = 0.5;
    drawHoleMarker(x, z);
    ctx.globalAlpha = 1;
  }
}

function adjustBrightness(hex, amount) {
  const r = Math.max(0, Math.min(255, parseInt(hex.slice(1, 3), 16) + amount));
  const g = Math.max(0, Math.min(255, parseInt(hex.slice(3, 5), 16) + amount));
  const b = Math.max(0, Math.min(255, parseInt(hex.slice(5, 7), 16) + amount));
  return `rgb(${r},${g},${b})`;
}

// ============================================================
// INPUT HANDLING
// ============================================================
const container = document.getElementById('canvas-container');

container.addEventListener('mousedown', (e) => {
  if (e.button === 1 || (e.button === 0 && e.altKey)) {
    // Middle click or Alt+click = pan
    isPanning = true;
    panStartX = e.clientX;
    panStartY = e.clientY;
    panStartCamX = camX;
    panStartCamY = camY;
    container.style.cursor = 'grabbing';
    e.preventDefault();
    return;
  }

  if (e.button === 0) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const cell = screenToWorld(mx, my);
    placeAtCell(cell);
  }

  if (e.button === 2) {
    // Right click = erase
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const cell = screenToWorld(mx, my);
    delete pieces[`${cell.x},${cell.z}`];
    render();
  }
});

container.addEventListener('mousemove', (e) => {
  if (isPanning) {
    camX = panStartCamX + (e.clientX - panStartX);
    camY = panStartCamY + (e.clientY - panStartY);
    render();
    return;
  }

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const cell = screenToWorld(mx, my);
  hoverCell = cell;

  document.getElementById('coords').textContent = `x: ${cell.x}, z: ${cell.z}`;
  render();
});

container.addEventListener('mouseup', () => {
  if (isPanning) {
    isPanning = false;
    container.style.cursor = 'crosshair';
  }
});

container.addEventListener('mouseleave', () => {
  hoverCell = null;
  isPanning = false;
  container.style.cursor = 'crosshair';
  render();
});

container.addEventListener('wheel', (e) => {
  e.preventDefault();
  const delta = e.deltaY > 0 ? -0.1 : 0.1;
  const newZoom = Math.max(0.3, Math.min(3, zoom + delta));

  // Zoom toward mouse
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  camX = mx - (mx - camX) * (newZoom / zoom);
  camY = my - (my - camY) * (newZoom / zoom);
  zoom = newZoom;
  render();
}, { passive: false });

container.addEventListener('contextmenu', (e) => e.preventDefault());

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

  switch (e.key) {
    case 'r': case 'R': cyclePieceRotation(1); break;
    case 'q': case 'Q': cyclePieceRotation(-1); break;
    case '1': setViewAngle(0); break;
    case '2': setViewAngle(1); break;
    case '3': setViewAngle(2); break;
    case '4': setViewAngle(3); break;
    case 'b': case 'B': selectTool('ball'); break;
    case 'h': case 'H': selectTool('hole'); break;
    case 'e': case 'E': selectTool('eraser'); break;
    case 'Escape': closeExport(); break;
  }
});

function placeAtCell(cell) {
  switch (currentTool) {
    case 'piece':
      pieces[`${cell.x},${cell.z}`] = { model: selectedPiece, rotation: pieceRotation };
      break;
    case 'ball':
      ballStart = { x: cell.x, z: cell.z };
      break;
    case 'hole':
      holePos = { x: cell.x, z: cell.z };
      break;
    case 'eraser':
      delete pieces[`${cell.x},${cell.z}`];
      break;
  }
  render();
}

// ============================================================
// EXPORT
// ============================================================
function exportCourse() {
  const name = document.getElementById('course-name').value || 'Untitled';
  const par = parseInt(document.getElementById('course-par').value) || 3;

  let pieceLines = [];
  const sorted = Object.entries(pieces).sort((a, b) => {
    const [ax, az] = a[0].split(',').map(Number);
    const [bx, bz] = b[0].split(',').map(Number);
    return az !== bz ? az - bz : ax - bx;
  });

  for (const [key, piece] of sorted) {
    const [x, z] = key.split(',').map(Number);
    if (piece.rotation !== 0) {
      pieceLines.push(`                PiecePlacement(model: "${piece.model}", x: ${x}, z: ${z}, rotation: ${piece.rotation}),`);
    } else {
      pieceLines.push(`                PiecePlacement(model: "${piece.model}", x: ${x}, z: ${z}),`);
    }
  }

  const swift = `        CourseDefinition(
            name: "${name}",
            par: ${par},
            pieces: [
${pieceLines.join('\n')}
            ],
            ballStart: GridPosition(x: ${ballStart.x}, z: ${ballStart.z}),
            holePosition: GridPosition(x: ${holePos.x}, z: ${holePos.z})
        ),`;

  document.getElementById('export-title').textContent = 'Swift CourseDefinition';
  document.getElementById('export-text').value = swift;
  document.getElementById('export-modal').classList.add('visible');
}

function exportJSON() {
  const name = document.getElementById('course-name').value || 'Untitled';
  const par = parseInt(document.getElementById('course-par').value) || 3;

  const piecesArray = [];
  for (const [key, piece] of Object.entries(pieces)) {
    const [x, z] = key.split(',').map(Number);
    piecesArray.push({ model: piece.model, position: { x, z }, rotation: piece.rotation });
  }
  piecesArray.sort((a, b) => a.position.z !== b.position.z ? a.position.z - b.position.z : a.position.x - b.position.x);

  const json = JSON.stringify({
    name,
    par,
    pieces: piecesArray,
    ballStart: { x: ballStart.x, z: ballStart.z },
    holePosition: { x: holePos.x, z: holePos.z },
    holeModel: 'hole-round'
  }, null, 2);

  document.getElementById('export-title').textContent = 'JSON Course';
  document.getElementById('export-text').value = json;
  document.getElementById('export-modal').classList.add('visible');
}

function importJSON() {
  const input = prompt('Paste JSON course definition:');
  if (!input) return;

  try {
    const data = JSON.parse(input);
    pieces = {};
    for (const p of data.pieces) {
      const x = p.position ? p.position.x : p.x;
      const z = p.position ? p.position.z : p.z;
      pieces[`${x},${z}`] = { model: p.model, rotation: p.rotation || 0 };
    }
    if (data.ballStart) {
      ballStart = { x: data.ballStart.x, z: data.ballStart.z };
    }
    if (data.holePosition) {
      holePos = { x: data.holePosition.x, z: data.holePosition.z };
    }
    document.getElementById('course-name').value = data.name || 'Imported';
    document.getElementById('course-par').value = data.par || 3;
    render();
  } catch (e) {
    alert('Invalid JSON: ' + e.message);
  }
}

function copyExport() {
  const text = document.getElementById('export-text');
  text.select();
  navigator.clipboard.writeText(text.value);
  // Flash the button
  const btn = event.target;
  btn.textContent = 'Copied!';
  setTimeout(() => btn.textContent = 'Copy to Clipboard', 1500);
}

function closeExport() {
  document.getElementById('export-modal').classList.remove('visible');
}

function clearAll() {
  if (!confirm('Clear all pieces?')) return;
  pieces = {};
  ballStart = { x: 0, z: 0 };
  holePos = { x: 2, z: 2 };
  render();
}

// ============================================================
// INIT
// ============================================================
buildPalette();
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Load "First Putt" as default
pieces = {
  '0,0': { model: 'end', rotation: 0 },
  '0,1': { model: 'straight', rotation: 0 },
  '0,2': { model: 'straight', rotation: 0 },
  '0,3': { model: 'end', rotation: 0 },
};
ballStart = { x: 0, z: 0 };
holePos = { x: 0, z: 3 };
render();
</script>

</body>
</html>
