<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FingerGolf Level Editor</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    display: flex;
    height: 100vh;
    overflow: hidden;
    user-select: none;
  }

  /* Sidebar */
  #sidebar {
    width: 280px;
    background: #16213e;
    border-right: 1px solid #0f3460;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
  }
  #sidebar h2 {
    padding: 16px;
    font-size: 18px;
    border-bottom: 1px solid #0f3460;
    color: #4ecca3;
  }

  .section { padding: 12px 16px; border-bottom: 1px solid #0f3460; }
  .section h3 { font-size: 13px; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }

  label { display: block; font-size: 13px; margin-bottom: 4px; color: #aaa; }
  input[type="text"], input[type="number"] {
    width: 100%;
    padding: 6px 10px;
    background: #1a1a2e;
    border: 1px solid #0f3460;
    border-radius: 6px;
    color: #e0e0e0;
    font-size: 14px;
    margin-bottom: 8px;
  }
  input:focus { outline: none; border-color: #4ecca3; }

  /* Piece palette */
  #palette {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
  }
  .piece-category { margin-bottom: 12px; }
  .piece-category h4 {
    font-size: 11px;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 4px;
    padding: 0 4px;
  }
  .piece-btn {
    display: inline-block;
    padding: 4px 8px;
    margin: 2px;
    background: #1a1a2e;
    border: 1px solid #0f3460;
    border-radius: 4px;
    color: #ccc;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.15s;
  }
  .piece-btn:hover { background: #0f3460; color: #fff; }
  .piece-btn.selected { background: #4ecca3; color: #1a1a2e; border-color: #4ecca3; font-weight: 600; }

  .special-btn {
    display: inline-block;
    padding: 5px 10px;
    margin: 2px;
    border: 1px solid;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    font-weight: 600;
  }
  .ball-btn { background: #2d5016; border-color: #4ecca3; color: #4ecca3; }
  .ball-btn.selected { background: #4ecca3; color: #1a1a2e; }
  .hole-btn { background: #501616; border-color: #e74c3c; color: #e74c3c; }
  .hole-btn.selected { background: #e74c3c; color: #fff; }
  .eraser-btn { background: #3d2c08; border-color: #f39c12; color: #f39c12; }
  .eraser-btn.selected { background: #f39c12; color: #1a1a2e; }

  /* Main area */
  #main {
    flex: 1;
    display: flex;
    flex-direction: column;
  }

  /* Toolbar */
  #toolbar {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    background: #16213e;
    border-bottom: 1px solid #0f3460;
    gap: 12px;
    flex-wrap: wrap;
  }
  .toolbar-group {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .toolbar-group span { font-size: 12px; color: #888; margin-right: 4px; }
  .tb-btn {
    padding: 6px 12px;
    background: #1a1a2e;
    border: 1px solid #0f3460;
    border-radius: 4px;
    color: #ccc;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s;
  }
  .tb-btn:hover { background: #0f3460; color: #fff; }
  .tb-btn.active { background: #4ecca3; color: #1a1a2e; border-color: #4ecca3; }
  .tb-btn.accent { background: #0f3460; border-color: #4ecca3; color: #4ecca3; }
  .tb-btn.accent:hover { background: #4ecca3; color: #1a1a2e; }
  .tb-btn.danger { border-color: #e74c3c; color: #e74c3c; }
  .tb-btn.danger:hover { background: #e74c3c; color: #fff; }

  .toolbar-sep { width: 1px; height: 24px; background: #0f3460; }

  #rotation-label {
    font-size: 12px;
    color: #4ecca3;
    font-weight: 600;
    min-width: 30px;
    text-align: center;
  }

  /* Viewport */
  #viewport {
    flex: 1;
    position: relative;
    overflow: hidden;
  }
  #viewport canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  /* Coords display */
  #coords {
    position: absolute;
    bottom: 12px;
    left: 12px;
    font-size: 12px;
    color: #aaa;
    pointer-events: none;
    background: rgba(0,0,0,0.5);
    padding: 4px 8px;
    border-radius: 4px;
  }

  /* Loading indicator */
  #loading {
    position: absolute;
    top: 12px;
    right: 12px;
    font-size: 12px;
    color: #4ecca3;
    background: rgba(0,0,0,0.7);
    padding: 4px 10px;
    border-radius: 4px;
    display: none;
  }
  #loading.visible { display: block; }

  /* Export modal */
  #export-modal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }
  #export-modal.visible { display: flex; }
  #export-content {
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 12px;
    padding: 24px;
    width: 90%;
    max-width: 700px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
  }
  #export-content h2 { margin-bottom: 12px; color: #4ecca3; }
  #export-content textarea {
    flex: 1;
    min-height: 300px;
    background: #1a1a2e;
    color: #4ecca3;
    border: 1px solid #0f3460;
    border-radius: 8px;
    padding: 12px;
    font-family: 'SF Mono', 'Menlo', monospace;
    font-size: 12px;
    resize: none;
  }
  #export-content .modal-btns {
    display: flex;
    gap: 8px;
    margin-top: 12px;
    justify-content: flex-end;
  }
</style>
</head>
<body>

<div id="sidebar">
  <h2>FingerGolf Level Editor</h2>

  <div class="section">
    <h3>Course Info</h3>
    <label>Name</label>
    <input type="text" id="course-name" value="First Putt" />
    <label>Par</label>
    <input type="number" id="course-par" value="2" min="1" max="12" />
  </div>

  <div class="section">
    <h3>Tools</h3>
    <div style="margin-bottom: 8px;">
      <span class="special-btn ball-btn" id="ball-tool" onclick="selectTool('ball')">Ball Start</span>
      <span class="special-btn hole-btn" id="hole-tool" onclick="selectTool('hole')">Hole</span>
      <span class="special-btn eraser-btn" id="eraser-tool" onclick="selectTool('eraser')">Eraser</span>
    </div>
  </div>

  <div class="section" style="flex:1; display:flex; flex-direction:column; min-height:0;">
    <h3>Pieces</h3>
    <div id="palette"></div>
  </div>
</div>

<div id="main">
  <div id="toolbar">
    <div class="toolbar-group">
      <span>View:</span>
      <button class="tb-btn active" onclick="setViewAngle(0)" id="view-0">NE</button>
      <button class="tb-btn" onclick="setViewAngle(1)" id="view-1">SE</button>
      <button class="tb-btn" onclick="setViewAngle(2)" id="view-2">SW</button>
      <button class="tb-btn" onclick="setViewAngle(3)" id="view-3">NW</button>
    </div>

    <div class="toolbar-sep"></div>

    <div class="toolbar-group">
      <span>Piece Rot:</span>
      <button class="tb-btn" onclick="cyclePieceRotation(-1)">&larr;</button>
      <span id="rotation-label">0&deg;</span>
      <button class="tb-btn" onclick="cyclePieceRotation(1)">&rarr;</button>
    </div>

    <div class="toolbar-sep"></div>

    <div class="toolbar-group">
      <button class="tb-btn accent" onclick="exportCourse()">Export Swift</button>
      <button class="tb-btn accent" onclick="exportJSON()">Export JSON</button>
      <button class="tb-btn" onclick="importJSON()">Import JSON</button>
    </div>

    <div style="flex:1"></div>

    <div class="toolbar-group">
      <button class="tb-btn" onclick="fitCamera()">Fit View (F)</button>
      <button class="tb-btn danger" onclick="clearAll()">Clear All</button>
    </div>
  </div>

  <div id="viewport">
    <div id="coords"></div>
    <div id="loading">Loading model...</div>
  </div>
</div>

<div id="export-modal">
  <div id="export-content">
    <h2 id="export-title">Export</h2>
    <textarea id="export-text" readonly></textarea>
    <div class="modal-btns">
      <button class="tb-btn" onclick="copyExport()">Copy to Clipboard</button>
      <button class="tb-btn" onclick="closeExport()">Close</button>
    </div>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

// ============================================================
// CONFIGURATION
// ============================================================
const MODEL_BASE = 'FingerGolf/MinigolfModels/';
const TEXTURE_PATH = MODEL_BASE + 'Textures/colormap.png';

// ============================================================
// STATE
// ============================================================
let pieces = {};
let overlays = {}; // "x,z" -> { model, rotation } for windmill on tunnel stacking
let ballStart = { x: 0, z: 0 };
let holePos = { x: 0, z: 3 };
let viewAngle = 0;
let selectedPiece = 'end';
let currentTool = 'piece';
let pieceRotation = 0;
let hoverCell = null;

// Stacking rules: only these overlay types can go on top of tunnel types
const TUNNEL_TYPES = ['tunnel-narrow', 'tunnel-wide', 'tunnel-double'];
const OVERLAY_TYPES = ['structure-windmill', 'windmill'];

// Undo
let undoStack = [];
const MAX_UNDO = 50;

function saveUndoState() {
  undoStack.push({
    pieces: JSON.parse(JSON.stringify(pieces)),
    overlays: JSON.parse(JSON.stringify(overlays)),
    ballStart: { ...ballStart },
    holePos: { ...holePos },
  });
  if (undoStack.length > MAX_UNDO) undoStack.shift();
}

const modelCache = {};
let colormapMaterial = null;
const sceneObjects = {};
const overlayObjects = {}; // scene objects for overlay layer
let ballMarker = null;
let holeMarker = null;
let hoverMarker = null;

const ISO_ANGLES = [
  Math.PI / 4,
  Math.PI * 3 / 4,
  Math.PI * 5 / 4,
  Math.PI * 7 / 4,
];
const CAM_ELEVATION = Math.atan(1 / Math.sqrt(2));
const CAM_DISTANCE = 20;

// ============================================================
// THREE.JS SETUP
// ============================================================
const viewport = document.getElementById('viewport');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e);

const frustumSize = 8;
let aspect = viewport.clientWidth / viewport.clientHeight;
const camera = new THREE.OrthographicCamera(
  -frustumSize * aspect / 2, frustumSize * aspect / 2,
  frustumSize / 2, -frustumSize / 2, 0.1, 100
);
scene.add(camera);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(viewport.clientWidth, viewport.clientHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
viewport.appendChild(renderer.domElement);

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Invisible ground plane for raycasting
const groundPlane = new THREE.Mesh(
  new THREE.PlaneGeometry(100, 100),
  new THREE.MeshBasicMaterial({ visible: false })
);
groundPlane.rotation.x = -Math.PI / 2;
scene.add(groundPlane);

// Grid
const gridHelper = new THREE.GridHelper(40, 40, 0x0f3460, 0x0a1a30);
gridHelper.position.y = -0.01;
scene.add(gridHelper);

// ============================================================
// LIGHTING
// ============================================================
const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
sunLight.position.set(5, 15, 5);
sunLight.castShadow = true;
sunLight.shadow.mapSize.set(2048, 2048);
sunLight.shadow.camera.left = -20;
sunLight.shadow.camera.right = 20;
sunLight.shadow.camera.top = 20;
sunLight.shadow.camera.bottom = -20;
scene.add(sunLight);

scene.add(new THREE.HemisphereLight(0x87ceeb, 0x556644, 0.6));
scene.add(new THREE.AmbientLight(0xc0c8d0, 0.4));

// ============================================================
// CAMERA
// ============================================================
let cameraTarget = new THREE.Vector3(0, 0, 1.5);
let currentCamAngle = ISO_ANGLES[0];
let targetCamAngle = ISO_ANGLES[0];

function updateCameraPosition(immediate) {
  if (!immediate) {
    const diff = targetCamAngle - currentCamAngle;
    let shortDiff = ((diff + Math.PI) % (Math.PI * 2)) - Math.PI;
    if (shortDiff < -Math.PI) shortDiff += Math.PI * 2;
    currentCamAngle += shortDiff * 0.15;
  } else {
    currentCamAngle = targetCamAngle;
  }

  camera.position.set(
    cameraTarget.x + Math.sin(currentCamAngle) * Math.cos(CAM_ELEVATION) * CAM_DISTANCE,
    cameraTarget.y + Math.sin(CAM_ELEVATION) * CAM_DISTANCE,
    cameraTarget.z + Math.cos(currentCamAngle) * Math.cos(CAM_ELEVATION) * CAM_DISTANCE
  );
  camera.lookAt(cameraTarget);
}

function fitCameraToScene() {
  const keys = Object.keys(pieces);
  if (keys.length === 0) {
    cameraTarget.set(0, 0, 1.5);
    camera.zoom = 1;
    camera.updateProjectionMatrix();
    return;
  }

  let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
  for (const key of keys) {
    const [x, z] = key.split(',').map(Number);
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minZ = Math.min(minZ, z);
    maxZ = Math.max(maxZ, z);
  }
  minX = Math.min(minX, ballStart.x, holePos.x);
  maxX = Math.max(maxX, ballStart.x, holePos.x);
  minZ = Math.min(minZ, ballStart.z, holePos.z);
  maxZ = Math.max(maxZ, ballStart.z, holePos.z);

  cameraTarget.set((minX + maxX + 1) / 2, 0, (minZ + maxZ + 1) / 2);

  const maxExtent = Math.max(maxX - minX + 2, maxZ - minZ + 2, 4);
  camera.zoom = frustumSize / (maxExtent * 1.2);
  camera.updateProjectionMatrix();
}

// ============================================================
// MODEL LOADING
// ============================================================
const objLoader = new OBJLoader();
const textureLoader = new THREE.TextureLoader();

function loadTexture() {
  return new Promise((resolve) => {
    textureLoader.load(TEXTURE_PATH,
      (tex) => {
        tex.colorSpace = THREE.SRGBColorSpace;
        colormapMaterial = new THREE.MeshLambertMaterial({ map: tex, side: THREE.DoubleSide });
        resolve();
      },
      undefined,
      () => {
        console.warn('Could not load colormap, using fallback material');
        colormapMaterial = new THREE.MeshLambertMaterial({ color: 0x4ecca3, side: THREE.DoubleSide });
        resolve();
      }
    );
  });
}

function loadModel(name) {
  return new Promise((resolve) => {
    if (modelCache[name]) {
      resolve(modelCache[name].clone());
      return;
    }

    showLoading(true);
    objLoader.load(MODEL_BASE + name + '.obj',
      (obj) => {
        obj.traverse((child) => {
          if (child.isMesh) {
            child.material = colormapMaterial.clone();
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        modelCache[name] = obj;
        showLoading(false);
        resolve(obj.clone());
      },
      undefined,
      () => {
        // Fallback box
        const cat = getCategoryForPiece(name);
        const colors = CATEGORY_COLORS[cat] || CATEGORY_COLORS['Basic'];
        const geo = new THREE.BoxGeometry(0.9, 0.15, 0.9);
        const mat = new THREE.MeshLambertMaterial({ color: colors.fill });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = 0.075;
        mesh.castShadow = true;
        const group = new THREE.Group();
        group.add(mesh);
        modelCache[name] = group;
        showLoading(false);
        resolve(group.clone());
      }
    );
  });
}

function showLoading(show) {
  document.getElementById('loading').classList.toggle('visible', show);
}

// ============================================================
// SCENE BUILDING
// ============================================================
async function placePieceInScene(x, z, piece) {
  const key = `${x},${z}`;
  if (sceneObjects[key]) {
    scene.remove(sceneObjects[key]);
    delete sceneObjects[key];
  }

  const model = await loadModel(piece.model);
  model.position.set(x + 0.5, 0, z + 0.5);
  model.rotation.y = piece.rotation * Math.PI / 180;
  scene.add(model);
  sceneObjects[key] = model;
}

function removePieceFromScene(x, z) {
  const key = `${x},${z}`;
  if (sceneObjects[key]) {
    scene.remove(sceneObjects[key]);
    delete sceneObjects[key];
  }
}

async function placeOverlayInScene(x, z, piece) {
  const key = `${x},${z}`;
  if (overlayObjects[key]) {
    scene.remove(overlayObjects[key]);
    delete overlayObjects[key];
  }

  const model = await loadModel(piece.model);
  model.position.set(x + 0.5, 0, z + 0.5);
  model.rotation.y = piece.rotation * Math.PI / 180;
  scene.add(model);
  overlayObjects[key] = model;
}

function removeOverlayFromScene(x, z) {
  const key = `${x},${z}`;
  if (overlayObjects[key]) {
    scene.remove(overlayObjects[key]);
    delete overlayObjects[key];
  }
}

function updateBallMarker() {
  if (ballMarker) scene.remove(ballMarker);
  const geo = new THREE.SphereGeometry(0.1, 16, 16);
  const mat = new THREE.MeshLambertMaterial({ color: 0x4ecca3, emissive: 0x4ecca3, emissiveIntensity: 0.3 });
  ballMarker = new THREE.Mesh(geo, mat);
  ballMarker.position.set(ballStart.x + 0.5, 0.1, ballStart.z + 0.5);
  ballMarker.castShadow = true;
  scene.add(ballMarker);
}

function updateHoleMarker() {
  if (holeMarker) scene.remove(holeMarker);
  holeMarker = new THREE.Group();

  // Dark circle
  const holeGeo = new THREE.CircleGeometry(0.15, 24);
  const holeMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
  const holeMesh = new THREE.Mesh(holeGeo, holeMat);
  holeMesh.rotation.x = -Math.PI / 2;
  holeMesh.position.y = 0.01;
  holeMarker.add(holeMesh);

  // Pole
  const poleGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.6, 8);
  const poleMat = new THREE.MeshLambertMaterial({ color: 0xcccccc });
  const pole = new THREE.Mesh(poleGeo, poleMat);
  pole.position.y = 0.3;
  holeMarker.add(pole);

  // Flag
  const flagGeo = new THREE.PlaneGeometry(0.25, 0.15);
  const flagMat = new THREE.MeshLambertMaterial({ color: 0xe74c3c, side: THREE.DoubleSide });
  const flag = new THREE.Mesh(flagGeo, flagMat);
  flag.position.set(0.125, 0.525, 0);
  holeMarker.add(flag);

  holeMarker.position.set(holePos.x + 0.5, 0, holePos.z + 0.5);
  scene.add(holeMarker);
}

function updateHoverMarker(x, z) {
  if (hoverMarker) { scene.remove(hoverMarker); hoverMarker = null; }
  if (x === null || currentTool === 'eraser') return;

  if (currentTool === 'piece') {
    const geo = new THREE.BoxGeometry(0.95, 0.02, 0.95);
    const mat = new THREE.MeshBasicMaterial({ color: 0x4ecca3, transparent: true, opacity: 0.3 });
    hoverMarker = new THREE.Mesh(geo, mat);
    hoverMarker.position.set(x + 0.5, 0.01, z + 0.5);
  } else if (currentTool === 'ball') {
    const geo = new THREE.SphereGeometry(0.08, 16, 16);
    const mat = new THREE.MeshBasicMaterial({ color: 0x4ecca3, transparent: true, opacity: 0.5 });
    hoverMarker = new THREE.Mesh(geo, mat);
    hoverMarker.position.set(x + 0.5, 0.1, z + 0.5);
  } else if (currentTool === 'hole') {
    const geo = new THREE.CircleGeometry(0.15, 24);
    const mat = new THREE.MeshBasicMaterial({ color: 0xe74c3c, transparent: true, opacity: 0.5 });
    hoverMarker = new THREE.Mesh(geo, mat);
    hoverMarker.rotation.x = -Math.PI / 2;
    hoverMarker.position.set(x + 0.5, 0.02, z + 0.5);
  }

  if (hoverMarker) scene.add(hoverMarker);
}

async function rebuildScene() {
  for (const key of Object.keys(sceneObjects)) {
    scene.remove(sceneObjects[key]);
    delete sceneObjects[key];
  }
  for (const key of Object.keys(overlayObjects)) {
    scene.remove(overlayObjects[key]);
    delete overlayObjects[key];
  }
  for (const [key, piece] of Object.entries(pieces)) {
    const [x, z] = key.split(',').map(Number);
    await placePieceInScene(x, z, piece);
  }
  for (const [key, piece] of Object.entries(overlays)) {
    const [x, z] = key.split(',').map(Number);
    await placeOverlayInScene(x, z, piece);
  }
  updateBallMarker();
  updateHoleMarker();
  fitCameraToScene();
}

// ============================================================
// PIECE CATALOG
// ============================================================
const PIECE_CATEGORIES = {
  'Basic': ['end', 'straight', 'corner', 'inner-corner', 'open', 'side', 'gap', 'crest'],
  'Turns': ['round-corner-a', 'round-corner-b', 'round-corner-c', 'round-large-corner', 'round-large-corner-open', 'skew-corner', 'skew-large-corner', 'skew-large-corner-open', 'square-corner-a'],
  'Ramps': ['ramp', 'ramp-low', 'ramp-medium', 'ramp-high', 'ramp-large', 'ramp-large-side', 'ramp-sharp', 'ramp-side', 'ramp-square'],
  'Hills': ['hill-corner', 'hill-round', 'hill-square', 'bump', 'bump-down', 'bump-walls', 'bump-down-walls'],
  'Obstacles': ['obstacle-block', 'obstacle-diamond', 'obstacle-triangle', 'narrow-block', 'narrow-round', 'narrow-square', 'block', 'block-borders'],
  'Tunnels': ['tunnel-narrow', 'tunnel-wide', 'tunnel-double'],
  'Splits': ['split', 'split-t', 'split-start', 'split-walls-to-open', 'walls-to-open'],
  'Walls': ['wall-left', 'wall-right'],
  'Structures': ['structure-windmill', 'windmill', 'structure-gate', 'structure-gate-building', 'structure-gate-wide', 'structure-gates', 'castle'],
  'Spline Concave': ['spline-concave', 'spline-concave-cap-back', 'spline-concave-cap-front', 'spline-concave-corner-large', 'spline-concave-corner-small', 'spline-concave-curve', 'spline-concave-looping', 'spline-concave-straight', 'spline-concave-straight-bend', 'spline-concave-straight-bend-large', 'spline-concave-straight-bump-down', 'spline-concave-straight-bump-up', 'spline-concave-straight-hill-beginning', 'spline-concave-straight-hill-complete', 'spline-concave-straight-hill-complete-half', 'spline-concave-straight-hill-end', 'spline-concave-straight-skew-left', 'spline-concave-straight-skew-left-side', 'spline-concave-straight-skew-right', 'spline-concave-straight-skew-right-side', 'spline-concave-corner-large-ramp', 'spline-concave-corner-small-ramp'],
  'Spline Default': ['spline-default', 'spline-default-cap-back', 'spline-default-cap-front', 'spline-default-corner-large', 'spline-default-corner-small', 'spline-default-curve', 'spline-default-looping', 'spline-default-straight', 'spline-default-straight-bend', 'spline-default-straight-bend-large', 'spline-default-straight-bump-down', 'spline-default-straight-bump-up', 'spline-default-straight-hill-beginning', 'spline-default-straight-hill-complete', 'spline-default-straight-hill-complete-half', 'spline-default-straight-hill-end', 'spline-default-straight-skew-left', 'spline-default-straight-skew-left-side', 'spline-default-straight-skew-right', 'spline-default-straight-skew-right-side', 'spline-default-corner-large-ramp', 'spline-default-corner-small-ramp'],
  'Support': ['support', 'support-bottom', 'support-low', 'support-low-bottom', 'supports', 'supports-bottom', 'supports-low', 'supports-low-bottom'],
};

const CATEGORY_COLORS = {
  'Basic':          { fill: '#4ecca3' },
  'Turns':          { fill: '#6c9bdb' },
  'Ramps':          { fill: '#e8a838' },
  'Hills':          { fill: '#c8a050' },
  'Obstacles':      { fill: '#e06060' },
  'Tunnels':        { fill: '#9b6ed0' },
  'Splits':         { fill: '#5cb8b2' },
  'Walls':          { fill: '#a0a0a0' },
  'Structures':     { fill: '#d0a0d0' },
  'Spline Concave': { fill: '#70b870' },
  'Spline Default': { fill: '#80c880' },
  'Support':        { fill: '#808888' },
};

function getCategoryForPiece(model) {
  for (const [cat, pcs] of Object.entries(PIECE_CATEGORIES)) {
    if (pcs.includes(model)) return cat;
  }
  return 'Basic';
}

// ============================================================
// PALETTE
// ============================================================
function buildPalette() {
  const pal = document.getElementById('palette');
  pal.innerHTML = '';
  for (const [cat, models] of Object.entries(PIECE_CATEGORIES)) {
    const div = document.createElement('div');
    div.className = 'piece-category';
    const h4 = document.createElement('h4');
    h4.textContent = cat;
    div.appendChild(h4);
    for (const m of models) {
      const btn = document.createElement('span');
      btn.className = 'piece-btn';
      btn.textContent = m;
      btn.dataset.model = m;
      if (m === selectedPiece && currentTool === 'piece') btn.classList.add('selected');
      btn.onclick = () => {
        selectedPiece = m;
        currentTool = 'piece';
        updateToolHighlights();
      };
      div.appendChild(btn);
    }
    pal.appendChild(div);
  }
}

function updateToolHighlights() {
  document.querySelectorAll('.piece-btn').forEach(b => {
    b.classList.toggle('selected', b.dataset.model === selectedPiece && currentTool === 'piece');
  });
  document.getElementById('ball-tool').classList.toggle('selected', currentTool === 'ball');
  document.getElementById('hole-tool').classList.toggle('selected', currentTool === 'hole');
  document.getElementById('eraser-tool').classList.toggle('selected', currentTool === 'eraser');
}

// ============================================================
// GLOBAL FUNCTIONS (onclick handlers)
// ============================================================
window.selectTool = function(tool) {
  currentTool = tool;
  updateToolHighlights();
};

window.setViewAngle = function(angle) {
  viewAngle = angle;
  targetCamAngle = ISO_ANGLES[angle];
  for (let i = 0; i < 4; i++) {
    document.getElementById('view-' + i).classList.toggle('active', i === angle);
  }
};

window.cyclePieceRotation = function(dir) {
  pieceRotation = ((pieceRotation / 90 + dir + 4) % 4) * 90;
  document.getElementById('rotation-label').textContent = pieceRotation + '\u00B0';
};

window.fitCamera = fitCameraToScene;

window.exportCourse = function() {
  const name = document.getElementById('course-name').value || 'Untitled';
  const par = parseInt(document.getElementById('course-par').value) || 3;
  const pieceLines = [];
  // Combine pieces and overlays into a single list
  const allEntries = [...Object.entries(pieces), ...Object.entries(overlays)];
  const sorted = allEntries.sort((a, b) => {
    const [ax, az] = a[0].split(',').map(Number);
    const [bx, bz] = b[0].split(',').map(Number);
    return az !== bz ? az - bz : ax - bx;
  });
  for (const [key, piece] of sorted) {
    const [x, z] = key.split(',').map(Number);
    if (piece.rotation !== 0) {
      pieceLines.push(`                PiecePlacement(model: "${piece.model}", x: ${x}, z: ${z}, rotation: ${piece.rotation}),`);
    } else {
      pieceLines.push(`                PiecePlacement(model: "${piece.model}", x: ${x}, z: ${z}),`);
    }
  }
  const swift = `        CourseDefinition(\n            name: "${name}",\n            par: ${par},\n            pieces: [\n${pieceLines.join('\n')}\n            ],\n            ballStart: GridPosition(x: ${ballStart.x}, z: ${ballStart.z}),\n            holePosition: GridPosition(x: ${holePos.x}, z: ${holePos.z})\n        ),`;
  document.getElementById('export-title').textContent = 'Swift CourseDefinition';
  document.getElementById('export-text').value = swift;
  document.getElementById('export-modal').classList.add('visible');
};

window.exportJSON = function() {
  const name = document.getElementById('course-name').value || 'Untitled';
  const par = parseInt(document.getElementById('course-par').value) || 3;
  const piecesArray = [];
  // Include both base pieces and overlays
  for (const [key, piece] of Object.entries(pieces)) {
    const [x, z] = key.split(',').map(Number);
    piecesArray.push({ model: piece.model, position: { x, z }, rotation: piece.rotation });
  }
  for (const [key, piece] of Object.entries(overlays)) {
    const [x, z] = key.split(',').map(Number);
    piecesArray.push({ model: piece.model, position: { x, z }, rotation: piece.rotation });
  }
  piecesArray.sort((a, b) => a.position.z !== b.position.z ? a.position.z - b.position.z : a.position.x - b.position.x);
  const json = JSON.stringify({
    name, par,
    pieces: piecesArray,
    ballStart: { x: ballStart.x, z: ballStart.z },
    holePosition: { x: holePos.x, z: holePos.z },
    holeModel: 'hole-round'
  }, null, 2);
  document.getElementById('export-title').textContent = 'JSON Course';
  document.getElementById('export-text').value = json;
  document.getElementById('export-modal').classList.add('visible');
};

window.importJSON = function() {
  const input = prompt('Paste JSON course definition:');
  if (!input) return;
  try {
    const data = JSON.parse(input);
    saveUndoState();
    pieces = {};
    overlays = {};
    // Separate overlay pieces from base pieces
    // If two pieces share a position and one is an overlay type on a tunnel, stack them
    const byPos = {};
    for (const p of data.pieces) {
      const x = p.position ? p.position.x : p.x;
      const z = p.position ? p.position.z : p.z;
      const key = `${x},${z}`;
      if (!byPos[key]) byPos[key] = [];
      byPos[key].push({ model: p.model, rotation: p.rotation || 0 });
    }
    for (const [key, entries] of Object.entries(byPos)) {
      if (entries.length === 1) {
        pieces[key] = entries[0];
      } else {
        // Multiple at same position - separate base from overlay
        const base = entries.find(e => !OVERLAY_TYPES.includes(e.model));
        const overlay = entries.find(e => OVERLAY_TYPES.includes(e.model));
        if (base) pieces[key] = base;
        if (overlay) overlays[key] = overlay;
        if (!base && !overlay) pieces[key] = entries[0]; // fallback
      }
    }
    if (data.ballStart) ballStart = { x: data.ballStart.x, z: data.ballStart.z };
    if (data.holePosition) holePos = { x: data.holePosition.x, z: data.holePosition.z };
    document.getElementById('course-name').value = data.name || 'Imported';
    document.getElementById('course-par').value = data.par || 3;
    rebuildScene();
  } catch (e) {
    alert('Invalid JSON: ' + e.message);
  }
};

window.copyExport = function() {
  const text = document.getElementById('export-text');
  text.select();
  navigator.clipboard.writeText(text.value);
  const btn = event.target;
  btn.textContent = 'Copied!';
  setTimeout(() => btn.textContent = 'Copy to Clipboard', 1500);
};

window.closeExport = function() {
  document.getElementById('export-modal').classList.remove('visible');
};

window.undo = function() {
  if (undoStack.length === 0) return;
  const state = undoStack.pop();
  pieces = state.pieces;
  overlays = state.overlays;
  ballStart = state.ballStart;
  holePos = state.holePos;
  rebuildScene();
};

window.clearAll = function() {
  if (!confirm('Clear all pieces?')) return;
  saveUndoState();
  pieces = {};
  overlays = {};
  ballStart = { x: 0, z: 0 };
  holePos = { x: 2, z: 2 };
  rebuildScene();
};

// ============================================================
// MOUSE INTERACTION
// ============================================================
function getGridCellFromMouse(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(groundPlane);
  if (intersects.length > 0) {
    const p = intersects[0].point;
    return { x: Math.floor(p.x), z: Math.floor(p.z) };
  }
  return null;
}

let isPanning = false;
let panStart = new THREE.Vector2();
let panTargetStart = new THREE.Vector3();

renderer.domElement.addEventListener('mousedown', (e) => {
  if (e.button === 1 || (e.button === 0 && e.altKey)) {
    isPanning = true;
    panStart.set(e.clientX, e.clientY);
    panTargetStart.copy(cameraTarget);
    e.preventDefault();
    return;
  }
  if (e.button === 0) {
    const cell = getGridCellFromMouse(e);
    if (cell) placeAtCell(cell);
  }
  if (e.button === 2) {
    const cell = getGridCellFromMouse(e);
    if (cell) {
      const key = `${cell.x},${cell.z}`;
      if (pieces[key] || overlays[key]) {
        saveUndoState();
        if (overlays[key]) {
          delete overlays[key];
          removeOverlayFromScene(cell.x, cell.z);
        } else {
          delete pieces[key];
          removePieceFromScene(cell.x, cell.z);
        }
      }
    }
  }
});

renderer.domElement.addEventListener('mousemove', (e) => {
  if (isPanning) {
    const dx = (e.clientX - panStart.x) * 0.02;
    const dy = (e.clientY - panStart.y) * 0.02;
    const angle = currentCamAngle;
    cameraTarget.x = panTargetStart.x - dx * Math.cos(angle) - dy * Math.sin(angle);
    cameraTarget.z = panTargetStart.z + dx * Math.sin(angle) - dy * Math.cos(angle);
    return;
  }
  const cell = getGridCellFromMouse(e);
  if (cell) {
    hoverCell = cell;
    document.getElementById('coords').textContent = `x: ${cell.x}, z: ${cell.z}`;
    updateHoverMarker(cell.x, cell.z);
  } else {
    hoverCell = null;
    updateHoverMarker(null);
  }
});

renderer.domElement.addEventListener('mouseup', () => { isPanning = false; });
renderer.domElement.addEventListener('mouseleave', () => { isPanning = false; hoverCell = null; updateHoverMarker(null); });

renderer.domElement.addEventListener('wheel', (e) => {
  e.preventDefault();
  camera.zoom = Math.max(0.3, Math.min(4, camera.zoom + (e.deltaY > 0 ? -0.05 : 0.05)));
  camera.updateProjectionMatrix();
}, { passive: false });

renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

async function placeAtCell(cell) {
  const key = `${cell.x},${cell.z}`;
  saveUndoState();
  switch (currentTool) {
    case 'piece': {
      const existing = pieces[key];
      const isOverlay = OVERLAY_TYPES.includes(selectedPiece);
      const existingIsTunnel = existing && TUNNEL_TYPES.includes(existing.model);

      if (isOverlay && existingIsTunnel) {
        // Stack overlay (windmill) on top of tunnel
        overlays[key] = { model: selectedPiece, rotation: pieceRotation };
        await placeOverlayInScene(cell.x, cell.z, overlays[key]);
      } else if (!isOverlay && TUNNEL_TYPES.includes(selectedPiece) && overlays[key]) {
        // Replacing tunnel under existing overlay - keep overlay
        pieces[key] = { model: selectedPiece, rotation: pieceRotation };
        await placePieceInScene(cell.x, cell.z, pieces[key]);
      } else {
        // Normal placement - replace piece and remove any overlay
        pieces[key] = { model: selectedPiece, rotation: pieceRotation };
        await placePieceInScene(cell.x, cell.z, pieces[key]);
        if (overlays[key]) {
          delete overlays[key];
          removeOverlayFromScene(cell.x, cell.z);
        }
      }
      break;
    }
    case 'ball':
      ballStart = { x: cell.x, z: cell.z };
      updateBallMarker();
      break;
    case 'hole':
      holePos = { x: cell.x, z: cell.z };
      updateHoleMarker();
      break;
    case 'eraser':
      if (overlays[key]) {
        delete overlays[key];
        removeOverlayFromScene(cell.x, cell.z);
      } else {
        delete pieces[key];
        removePieceFromScene(cell.x, cell.z);
      }
      break;
  }
}

// ============================================================
// KEYBOARD
// ============================================================
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
    e.preventDefault();
    window.undo();
    return;
  }
  switch (e.key) {
    case 'r': case 'R': window.cyclePieceRotation(1); break;
    case 'q': case 'Q': window.cyclePieceRotation(-1); break;
    case '1': window.setViewAngle(0); break;
    case '2': window.setViewAngle(1); break;
    case '3': window.setViewAngle(2); break;
    case '4': window.setViewAngle(3); break;
    case 'b': case 'B': window.selectTool('ball'); break;
    case 'h': case 'H': window.selectTool('hole'); break;
    case 'e': case 'E': window.selectTool('eraser'); break;
    case 'f': case 'F': fitCameraToScene(); break;
    case 'Escape': window.closeExport(); break;
  }
});

// ============================================================
// RESIZE
// ============================================================
function onResize() {
  const w = viewport.clientWidth;
  const h = viewport.clientHeight;
  aspect = w / h;
  camera.left = -frustumSize * aspect / 2;
  camera.right = frustumSize * aspect / 2;
  camera.top = frustumSize / 2;
  camera.bottom = -frustumSize / 2;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
}
window.addEventListener('resize', onResize);

// ============================================================
// ANIMATION LOOP
// ============================================================
function animate() {
  requestAnimationFrame(animate);
  updateCameraPosition(false);
  renderer.render(scene, camera);
}

// ============================================================
// INIT
// ============================================================
async function init() {
  buildPalette();
  await loadTexture();

  pieces = {
    '0,0': { model: 'end', rotation: 0 },
    '0,1': { model: 'straight', rotation: 0 },
    '0,2': { model: 'straight', rotation: 0 },
    '0,3': { model: 'end', rotation: 0 },
  };
  ballStart = { x: 0, z: 0 };
  holePos = { x: 0, z: 3 };

  await rebuildScene();
  updateCameraPosition(true);
  animate();
}

init();
</script>

</body>
</html>
